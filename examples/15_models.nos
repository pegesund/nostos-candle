# ModernBERT Model - Clean Implementation with Traits
# Demonstrates: pub traits, string interpolation, fold, clean model interface
# Run: nostos --use candle examples/15_models.nos

use candle.*

# =============================================================================
# Model Trait (public so it can be used across modules)
# =============================================================================

pub trait Model
    forward(self, tokens)
    encodeText(self, text)
end

# =============================================================================
# ModernBERT Model Type
# =============================================================================

type ModernBertModel = { weights: Safetensors, tokenizer: Tokenizer, hiddenSize: Int, numHeads: Int, headDim: Int, globalTheta: Float, localTheta: Float }

# Constructor
loadModernBert(modelPath, tokenizerPath) = {
    w = loadSafetensors(modelPath)
    t = loadTokenizer(tokenizerPath)
    ModernBertModel(w, t, 768, 12, 64, 160000.0, 10000.0)
}

# =============================================================================
# Attention Helpers
# =============================================================================

splitHeads(x, numHeads) = {
    shape = tensorShape(x)
    batch = shape[0]
    seq = shape[1]
    hidden = shape[2]
    headDim = hidden / numHeads
    reshaped = reshape(x, [batch, seq, numHeads, headDim])
    swapDims(reshaped, 1, 2)
}

mergeHeads(x) = {
    shape = tensorShape(x)
    batch = shape[0]
    numHeads = shape[1]
    seq = shape[2]
    headDim = shape[3]
    hidden = numHeads * headDim
    transposed = swapDims(x, 1, 2)
    reshape(transposed, [batch, seq, hidden])
}

applyRopeToQK(x, cos, sin) = {
    shape = tensorShape(x)
    headDim = shape[3]
    halfDim = headDim / 2
    x1 = narrow(x, 3, 0, halfDim)
    x2 = narrow(x, 3, halfDim, halfDim)
    cosHalf = narrow(cos, 1, 0, halfDim)
    sinHalf = narrow(sin, 1, 0, halfDim)
    cosB = unsqueeze(unsqueeze(cosHalf, 0), 0)
    sinB = unsqueeze(unsqueeze(sinHalf, 0), 0)
    rotX1 = tensorSub(tensorMul(x1, cosB), tensorMul(x2, sinB))
    rotX2 = tensorAdd(tensorMul(x1, sinB), tensorMul(x2, cosB))
    cat([rotX1, rotX2], 3)
}

# =============================================================================
# ModernBERT Components
# =============================================================================

modernBertAttention(x, wQKV, wO, cos, sin, numHeads, headDimF) = {
    qkv = linear(x, wQKV)
    shape = tensorShape(qkv)
    hidden = shape[2] / 3
    q = narrow(qkv, 2, 0, hidden)
    k = narrow(qkv, 2, hidden, hidden)
    v = narrow(qkv, 2, hidden * 2, hidden)
    qHeads = contiguous(splitHeads(q, numHeads))
    kHeads = contiguous(splitHeads(k, numHeads))
    vHeads = contiguous(splitHeads(v, numHeads))
    qRope = applyRopeToQK(qHeads, cos, sin)
    kRope = applyRopeToQK(kHeads, cos, sin)
    scale = tensorSqrt(fromList([headDimF]))
    kT = contiguous(swapDims(kRope, 2, 3))
    scores = matmul(qRope, kT)
    scaledScores = tensorDiv(scores, scale)
    attnWeights = softmax(scaledScores, 3)
    attnOutput = matmul(attnWeights, vHeads)
    merged = mergeHeads(contiguous(attnOutput))
    linear(merged, wO)
}

modernBertMLP(x, wI, wO) = {
    gateUp = linear(x, wI)
    shape = tensorShape(gateUp)
    intermediate = shape[2] / 2
    gate = narrow(gateUp, 2, 0, intermediate)
    up = narrow(gateUp, 2, intermediate, intermediate)
    hidden = geglu(gate, up)
    linear(hidden, wO)
}

# Single layer using string interpolation for weight names
modernBertLayer(x, weights, i, cos, sin, hiddenSize, numHeads, headDim) = {
    zerosBias = zeros([hiddenSize])
    headDimF = headDim * 1.0

    if i == 0 then {
        # Layer 0 has no attn_norm
        wQKV = getTensor(weights, "model.layers.0.attn.Wqkv.weight")
        wO = getTensor(weights, "model.layers.0.attn.Wo.weight")
        mlpNormW = getTensor(weights, "model.layers.0.mlp_norm.weight")
        wI = getTensor(weights, "model.layers.0.mlp.Wi.weight")
        wO2 = getTensor(weights, "model.layers.0.mlp.Wo.weight")

        attnOut = modernBertAttention(x, wQKV, wO, cos, sin, numHeads, headDimF)
        h1 = tensorAdd(x, attnOut)
        mlpIn = layerNorm(h1, mlpNormW, zerosBias)
        mlpOut = modernBertMLP(mlpIn, wI, wO2)
        tensorAdd(h1, mlpOut)
    } else {
        # Layers 1-21 use string interpolation for weight names
        attnNormW = getTensor(weights, "model.layers.${i}.attn_norm.weight")
        wQKV = getTensor(weights, "model.layers.${i}.attn.Wqkv.weight")
        wO = getTensor(weights, "model.layers.${i}.attn.Wo.weight")
        mlpNormW = getTensor(weights, "model.layers.${i}.mlp_norm.weight")
        wI = getTensor(weights, "model.layers.${i}.mlp.Wi.weight")
        wO2 = getTensor(weights, "model.layers.${i}.mlp.Wo.weight")

        attnIn = layerNorm(x, attnNormW, zerosBias)
        attnOut = modernBertAttention(attnIn, wQKV, wO, cos, sin, numHeads, headDimF)
        h1 = tensorAdd(x, attnOut)
        mlpIn = layerNorm(h1, mlpNormW, zerosBias)
        mlpOut = modernBertMLP(mlpIn, wI, wO2)
        tensorAdd(h1, mlpOut)
    }
}

# Run all 22 layers using fold
runAllLayers(x, weights, cosGlobal, sinGlobal, cosLocal, sinLocal, hiddenSize, numHeads, headDim) = {
    indices = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]
    indices.fold(x, (h, i) => {
        isGlobal = i % 3 == 0
        cos = if isGlobal then cosGlobal else cosLocal
        sin = if isGlobal then sinGlobal else sinLocal
        modernBertLayer(h, weights, i, cos, sin, hiddenSize, numHeads, headDim)
    })
}

# =============================================================================
# Model Trait Implementation
# =============================================================================

ModernBertModel: Model
    encodeText(self, text) = encode(self.tokenizer, text)

    forward(self, tokens) = {
        tokenTensor = unsqueeze(fromIntList(tokens), 0)
        seqLen = length(tokens)

        # Embeddings
        tokEmb = getTensor(self.weights, "model.embeddings.tok_embeddings.weight")
        embNormW = getTensor(self.weights, "model.embeddings.norm.weight")
        zerosBias = zeros([self.hiddenSize])

        embedded = embedding(tokenTensor, tokEmb)
        x = layerNorm(embedded, embNormW, zerosBias)

        # Compute RoPE frequencies
        ropeGlobal = ropeFreqs(seqLen, self.headDim, self.globalTheta)
        ropeLocal = ropeFreqs(seqLen, self.headDim, self.localTheta)

        # Run all 22 layers using fold
        runAllLayers(x, self.weights, ropeGlobal[0], ropeGlobal[1], ropeLocal[0], ropeLocal[1], self.hiddenSize, self.numHeads, self.headDim)
    }
end

# =============================================================================
# Generic Inference (works with any Model)
# =============================================================================

infer(model, text) = {
    tokens = model.encodeText(text)
    model.forward(tokens)
}

# =============================================================================
# Main
# =============================================================================

main() = {
    println("=== ModernBERT with Trait-Based Model Abstraction ===")
    println("Demonstrates: pub trait, string interpolation, fold\n")

    # Load model using constructor
    println("Loading ModernBERT...")
    model = loadModernBert(
        "/home/user/nostos-candle/models/modernbert-base.safetensors",
        "/home/user/nostos-candle/models/modernbert-tokenizer.json"
    )
    println("Model loaded!\n")

    # Run inference using trait methods
    text = "hello world"
    println("Input: \"" ++ text ++ "\"")
    tokens = model.encodeText(text)
    println("Tokens:")
    println(tokens)

    output = infer(model, text)

    println("\nOutput shape:")
    println(tensorShape(output))

    # Print first 5 values of CLS token
    slice = narrow(narrow(output, 0, 0, 1), 1, 0, 1)
    first = squeeze(squeeze(slice, 0), 0)
    vals = toList(narrow(first, 0, 0, 5))
    println("\nFirst 5 values of CLS:")
    println(vals)

    println("\nExpected (HuggingFace): [7.2328, -2.4966, 14.072, -0.492, -5.619]")

    println("\n=== Done ===")
    0
}
