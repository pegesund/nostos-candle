# Train LSTM on MNIST digit classification (Nostos + Candle).
#
# Treats each 28x28 image as a sequence of 28 rows (28 time steps, 28-dim input).
# Model: LSTM(28, 128) -> linear(128, 10) on last hidden state.
#
# Run: nostos --use candle tutorial/train_mnist.nos
use candle.*

# Forward pass: LSTM over 28 rows, take last hidden state, project to 10 classes
predict(lstm: LSTM, wOut: Tensor, images: Tensor) -> Tensor = {
    hidden = lstmSeq(lstm, images)       # [batch, 28, 128]
    last = hidden.lastOf(1)              # [batch, 128]
    linear(last, wOut)                   # [batch, 10]
}

main() = {
    println("Loading MNIST from safetensors...")
    data = loadSafetensors("tutorial/data/mnist.safetensors")
    trainImages = getTensor(data, "train_images")   # [60000, 28, 28]
    trainLabels = getTensor(data, "train_labels")    # [60000]
    testImages = getTensor(data, "test_images")      # [10000, 28, 28]
    testLabels = getTensor(data, "test_labels")      # [10000]

    println("  Train: " ++ show(tensorShape(trainImages)))
    println("  Test:  " ++ show(tensorShape(testImages)))

    # Create trainable model
    params = paramMapCreate()
    lstm = lstmTrainable(params, 28, 128)
    wOut = paramRandn(params, [10, 128])

    opt = adam(params, 0.001)

    batchSize = 128
    numEpochs = 3

    println("")
    println("Training LSTM on MNIST:")
    println("  Model: LSTM(28, 128) -> linear(128, 10)")
    println("  Optimizer: Adam(lr=0.001)")
    println("  Batch size: " ++ show(batchSize) ++ ", Epochs: " ++ show(numEpochs))
    println("")

    var epoch = 0
    while epoch < numEpochs {
        avgLoss = eachBatch(trainImages, trainLabels, batchSize, (images, labels) => {
            logits = predict(lstm, wOut, images)
            loss = crossEntropyLoss(logits, labels)
            trainStep(opt, loss)
        })
        println("  Epoch " ++ show(epoch + 1) ++ "/" ++ show(numEpochs) ++ " - avg loss: " ++ show(avgLoss))
        epoch = epoch + 1
    }

    # Evaluate on test set
    println("")
    println("Evaluating on test set...")
    correct = eachBatchCount(testImages, testLabels, 100, (images, labels) => {
        logits = predict(lstm, wOut, images)
        preds = argmax(logits, 1).squeeze(1)
        countEqual(preds, labels)
    })

    nTest = tensorShape(testImages)[0]
    pct = toFloat(correct) * 100.0 / toFloat(nTest)
    println("  Test accuracy: " ++ show(correct) ++ "/" ++ show(nTest) ++ " = " ++ show(pct) ++ "%")

    0
}
